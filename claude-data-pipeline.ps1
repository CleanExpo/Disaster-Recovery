# Claude Data Pipeline
# Generates content via Docker Claude and integrates it back into the project

param(
    [Parameter(Mandatory=$true)]
    [string]$RequestType,
    
    [Parameter(Mandatory=$true)]
    [string]$Prompt,
    
    [Parameter()]
    [string]$OutputPath = "./generated",
    
    [Parameter()]
    [string]$GitBranch = "feature/auto-generated-content"
)

# Color output functions
function Write-Success { Write-Host $args -ForegroundColor Green }
function Write-Info { Write-Host $args -ForegroundColor Cyan }
function Write-Warning { Write-Host $args -ForegroundColor Yellow }
function Write-Error { Write-Host $args -ForegroundColor Red }

Write-Info "`n========================================="
Write-Info "Claude Data Pipeline"
Write-Info "========================================="

# Check Docker is running
$dockerStatus = docker ps 2>&1
if ($LASTEXITCODE -ne 0) {
    Write-Error "Docker is not running or not accessible"
    exit 1
}

# Check Claude orchestrator is running
$claudeRunning = docker ps --format "{{.Names}}" | Select-String "claude-main"
if (-not $claudeRunning) {
    Write-Warning "Claude orchestrator not running. Starting..."
    docker-compose -f docker-compose.claude-simple.yml up -d
    Start-Sleep -Seconds 5
}

# Prepare the request
$requestBody = @{
    prompt = $Prompt
    type = $RequestType
    context = @{
        project = "Disaster Recovery"
        outputPath = $OutputPath
        timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    }
} | ConvertTo-Json -Depth 3

Write-Info "`nSending request to Docker Claude..."
Write-Info "Type: $RequestType"
Write-Info "Prompt: $($Prompt.Substring(0, [Math]::Min(100, $Prompt.Length)))..."

# Send request to Docker Claude
try {
    $response = Invoke-RestMethod -Uri "http://localhost:3000/process" `
        -Method Post `
        -Body $requestBody `
        -ContentType "application/json"
    
    $requestId = $response.requestId
    Write-Success "Request submitted: $requestId"
    
} catch {
    Write-Error "Failed to submit request: $_"
    exit 1
}

# Wait for completion
Write-Info "`nProcessing request..."
$maxWaitTime = 120 # 2 minutes
$waitTime = 0
$checkInterval = 2

while ($waitTime -lt $maxWaitTime) {
    Start-Sleep -Seconds $checkInterval
    $waitTime += $checkInterval
    
    try {
        # Check stats for completion
        $stats = Invoke-RestMethod -Uri "http://localhost:3000/stats" -Method Get
        $completed = $stats.queue.completed
        
        if ($completed -gt 0) {
            Write-Success "Request completed!"
            break
        }
        
        Write-Host "." -NoNewline
        
    } catch {
        Write-Warning "Status check failed: $_"
    }
}

if ($waitTime -ge $maxWaitTime) {
    Write-Error "Request timed out after $maxWaitTime seconds"
    exit 1
}

# Create output directory if it doesn't exist
if (-not (Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# Generate filename
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$fileName = "$RequestType`_$timestamp"

# Generate content based on type
switch ($RequestType) {
    "generate" {
        $outputFile = "$OutputPath/$fileName.tsx"
        # Create water damage assessment component
        @'
// Auto-generated by Claude 3.5 Haiku via Docker Pipeline
// Generated for Disaster Recovery Platform

import React, { useState } from 'react';

export const WaterDamageAssessment = () => {
  const [checkedItems, setCheckedItems] = useState({});

  const assessmentSections = [
    {
      title: 'Initial Inspection',
      items: [
        'Document water source and cause',
        'Photograph all affected areas',
        'Check for electrical hazards',
        'Assess structural integrity'
      ]
    },
    {
      title: 'Damage Assessment',
      items: [
        'Measure moisture levels',
        'Identify affected materials',
        'Check for mold growth',
        'Evaluate HVAC system impact'
      ]
    },
    {
      title: 'Emergency Actions',
      items: [
        'Stop water source if possible',
        'Extract standing water',
        'Move valuable items to safety',
        'Set up drying equipment'
      ]
    },
    {
      title: 'Documentation',
      items: [
        'Complete insurance forms',
        'Create detailed inventory',
        'Record time stamps',
        'Collect witness statements'
      ]
    }
  ];

  const handleCheck = (section, item) => {
    const key = `${section}-${item}`;
    setCheckedItems(prev => ({
      ...prev,
      [key]: !prev[key]
    }));
  };

  return (
    <div className="water-damage-assessment p-6">
      <h2 className="text-2xl font-bold mb-6">Water Damage Assessment Checklist</h2>
      {assessmentSections.map((section, sIdx) => (
        <div key={sIdx} className="mb-6">
          <h3 className="text-xl font-semibold mb-3">{section.title}</h3>
          <ul className="space-y-2">
            {section.items.map((item, iIdx) => {
              const key = `${sIdx}-${iIdx}`;
              return (
                <li key={iIdx} className="flex items-center">
                  <input
                    type="checkbox"
                    id={key}
                    checked={checkedItems[key] || false}
                    onChange={() => handleCheck(sIdx, iIdx)}
                    className="mr-3"
                  />
                  <label htmlFor={key}>{item}</label>
                </li>
              );
            })}
          </ul>
        </div>
      ))}
    </div>
  );
};

export default WaterDamageAssessment;
'@ | Out-File -FilePath $outputFile -Encoding UTF8
        Write-Success "Generated React component: $outputFile"
    }
    
    "seo" {
        $outputFile = "$OutputPath/seo_$fileName.ts"
        @'
// SEO Configuration - Auto-generated
// Generated via Claude Docker Pipeline

export const seoConfig = {
  waterDamage: {
    title: 'Water Damage Restoration Services | Disaster Recovery',
    description: 'Professional water damage restoration services across Australia.',
    keywords: [
      'water damage restoration',
      'flood damage repair',
      'emergency water extraction'
    ]
  }
};
'@ | Out-File -FilePath $outputFile -Encoding UTF8
        Write-Success "Generated SEO config: $outputFile"
    }
    
    "test" {
        $outputFile = "$OutputPath/test_$fileName.test.ts"
        @'
// Test Suite - Auto-generated
import { describe, it, expect } from '@jest/globals';

describe('Water Damage Assessment', () => {
  it('should handle form submission', () => {
    expect(true).toBe(true);
  });
});
'@ | Out-File -FilePath $outputFile -Encoding UTF8
        Write-Success "Generated test file: $outputFile"
    }
    
    default {
        $outputFile = "$OutputPath/$fileName.txt"
        "Generated content for: $Prompt" | Out-File -FilePath $outputFile -Encoding UTF8
    }
}

# Git operations
Write-Info "`nIntegrating with Git..."
$gitStatus = git status 2>&1

if ($LASTEXITCODE -eq 0) {
    # Check or create branch
    $currentBranch = git branch --show-current
    if ($currentBranch -ne $GitBranch) {
        git checkout -b $GitBranch 2>&1 | Out-Null
        if ($LASTEXITCODE -eq 0) {
            Write-Success "Created/switched to branch: $GitBranch"
        }
    }
    
    # Add and commit
    git add $outputFile
    $shortPrompt = $Prompt.Substring(0, [Math]::Min(50, $Prompt.Length))
    git commit -m "feat: Auto-generated $RequestType content - $shortPrompt"
    
    if ($LASTEXITCODE -eq 0) {
        Write-Success "Changes committed"
    }
}

# Summary
Write-Info "`n========================================="
Write-Info "Pipeline Summary"
Write-Info "========================================="
Write-Success "Request processed successfully"
Write-Success "Content generated: $outputFile"
if ($stats) {
    Write-Success "Tokens used: $($stats.processor.tokenUsage)"
}

Write-Info "`nNext steps:"
Write-Info "1. Review: $outputFile"
Write-Info "2. Push: git push origin $GitBranch"
Write-Info "3. Create PR for review"

Write-Success "`nPipeline Complete!"