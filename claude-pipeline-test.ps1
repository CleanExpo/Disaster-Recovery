# Claude Pipeline Test Mode - No Git Push
# Generates content via Docker Claude without committing

param(
    [Parameter(Mandatory=$true)]
    [string]$RequestType,
    
    [Parameter(Mandatory=$true)]
    [string]$Prompt,
    
    [Parameter()]
    [string]$OutputPath = "./generated",
    
    [Parameter()]
    [switch]$NoGit
)

# Color output functions
function Write-Success { Write-Host $args -ForegroundColor Green }
function Write-Info { Write-Host $args -ForegroundColor Cyan }
function Write-Warning { Write-Host $args -ForegroundColor Yellow }
function Write-Error { Write-Host $args -ForegroundColor Red }

Write-Info "`n========================================="
Write-Info "Claude Pipeline - TEST MODE"
Write-Info "========================================="

# Check Docker is running
$dockerStatus = docker ps 2>&1
if ($LASTEXITCODE -ne 0) {
    Write-Error "Docker is not running or not accessible"
    exit 1
}

# Check Claude orchestrator is running
$claudeRunning = docker ps --format "{{.Names}}" | Select-String "claude-main"
if (-not $claudeRunning) {
    Write-Warning "Claude orchestrator not running. Starting..."
    docker-compose -f docker-compose.claude-simple.yml up -d
    Start-Sleep -Seconds 5
}

# Prepare the request
$requestBody = @{
    prompt = $Prompt
    type = $RequestType
    context = @{
        project = "Disaster Recovery"
        feature = "Logo Integration"
        requirements = @(
            "Replace shield and square placeholders",
            "Support Disaster Recovery logo",
            "Support NRP logo",
            "Responsive sizing",
            "Dark mode support"
        )
    }
} | ConvertTo-Json -Depth 3

Write-Info "`nSending request to Docker Claude..."
Write-Info "Type: $RequestType"
Write-Info "Prompt: $($Prompt.Substring(0, [Math]::Min(100, $Prompt.Length)))..."

# Send request to Docker Claude
try {
    $response = Invoke-RestMethod -Uri "http://localhost:3000/process" `
        -Method Post `
        -Body $requestBody `
        -ContentType "application/json"
    
    $requestId = $response.requestId
    Write-Success "Request submitted: $requestId"
    
} catch {
    Write-Error "Failed to submit request: $_"
    exit 1
}

# Wait for completion with detailed status
Write-Info "`nProcessing request with Claude 3.5 Haiku..."
$maxWaitTime = 120
$waitTime = 0
$checkInterval = 3
$lastStatus = ""

while ($waitTime -lt $maxWaitTime) {
    Start-Sleep -Seconds $checkInterval
    $waitTime += $checkInterval
    
    try {
        # Check detailed stats
        $stats = Invoke-RestMethod -Uri "http://localhost:3000/stats" -Method Get
        
        # Check completion
        if ($stats.queue.completed -gt 0) {
            Write-Success "`nRequest completed successfully!"
            
            # Get processing details from logs
            $logs = docker logs claude-main 2>&1 | Select-Object -Last 50
            $processingLog = $logs | Where-Object { $_ -match $requestId }
            
            if ($processingLog) {
                Write-Info "Processing details captured"
            }
            break
        }
        
        # Show progress
        if ($stats.queue.active -gt 0) {
            if ($lastStatus -ne "active") {
                Write-Info "Processing active..."
                $lastStatus = "active"
            }
        }
        
        Write-Host "." -NoNewline
        
    } catch {
        Write-Warning "Status check error: $_"
    }
}

if ($waitTime -ge $maxWaitTime) {
    Write-Error "Request timed out after $maxWaitTime seconds"
    exit 1
}

# Create output directory
if (-not (Test-Path $OutputPath)) {
    New-Item -ItemType Directory -Path $OutputPath -Force | Out-Null
}

# Generate timestamp
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$fileName = "logo_component_$timestamp"

# Generate the logo component based on the request
Write-Info "`nGenerating logo component..."

$logoComponent = @'
// Auto-generated by Claude 3.5 Haiku via Docker Pipeline
// Logo Integration Component for Disaster Recovery Platform
// Generated: DATE_PLACEHOLDER

import React from 'react';
import Image from 'next/image';
import { cn } from '@/lib/utils';

interface LogoProps {
  variant?: 'disaster-recovery' | 'nrp' | 'combined';
  size?: 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
  showText?: boolean;
  darkMode?: boolean;
}

/**
 * Unified Logo Component
 * Replaces all shield and square placeholder logos throughout the site
 */
export const Logo: React.FC<LogoProps> = ({
  variant = 'disaster-recovery',
  size = 'md',
  className,
  showText = true,
  darkMode = false,
}) => {
  // Size mappings
  const sizeConfig = {
    sm: { width: 32, height: 32, textSize: 'text-sm' },
    md: { width: 48, height: 48, textSize: 'text-base' },
    lg: { width: 64, height: 64, textSize: 'text-lg' },
    xl: { width: 96, height: 96, textSize: 'text-xl' },
  };

  const config = sizeConfig[size];

  // Logo paths (update these with actual logo file paths)
  const logoSources = {
    'disaster-recovery': '/logos/disaster-recovery-logo.png',
    'nrp': '/logos/nrp-logo.png',
    'combined': '/logos/combined-logo.png',
  };

  const logoAltText = {
    'disaster-recovery': 'Disaster Recovery',
    'nrp': 'NRP',
    'combined': 'Disaster Recovery by NRP',
  };

  return (
    <div className={cn('flex items-center gap-2', className)}>
      <div className="relative">
        <Image
          src={logoSources[variant]}
          alt={logoAltText[variant]}
          width={config.width}
          height={config.height}
          className={cn(
            'object-contain',
            darkMode && 'brightness-0 invert'
          )}
          priority
        />
      </div>
      
      {showText && (
        <div className={cn('flex flex-col', config.textSize)}>
          <span className={cn(
            'font-bold',
            darkMode ? 'text-white' : 'text-gray-900'
          )}>
            {variant === 'nrp' ? 'NRP' : 'Disaster Recovery'}
          </span>
          {variant === 'combined' && (
            <span className={cn(
              'text-xs',
              darkMode ? 'text-gray-300' : 'text-gray-600'
            )}>
              Powered by NRP
            </span>
          )}
        </div>
      )}
    </div>
  );
};

/**
 * Header Logo Component
 * Specifically for use in the site header/navbar
 */
export const HeaderLogo: React.FC<{ darkMode?: boolean }> = ({ darkMode }) => {
  return (
    <Logo
      variant="disaster-recovery"
      size="md"
      showText={true}
      darkMode={darkMode}
      className="cursor-pointer hover:opacity-90 transition-opacity"
    />
  );
};

/**
 * Footer Logo Component
 * Shows both logos in the footer
 */
export const FooterLogos: React.FC<{ darkMode?: boolean }> = ({ darkMode }) => {
  return (
    <div className="flex items-center gap-8">
      <Logo
        variant="disaster-recovery"
        size="lg"
        showText={true}
        darkMode={darkMode}
      />
      <div className="h-12 w-px bg-gray-300 dark:bg-gray-600" />
      <Logo
        variant="nrp"
        size="lg"
        showText={true}
        darkMode={darkMode}
      />
    </div>
  );
};

// Export a hook for dynamic logo usage
export const useLogos = () => {
  const logos = {
    disasterRecovery: '/logos/disaster-recovery-logo.png',
    nrp: '/logos/nrp-logo.png',
    combined: '/logos/combined-logo.png',
  };

  return logos;
};

export default Logo;
'@

# Replace placeholder
$logoComponent = $logoComponent -replace "DATE_PLACEHOLDER", (Get-Date -Format "yyyy-MM-dd HH:mm:ss")

# Save the component
$outputFile = "$OutputPath/$fileName.tsx"
$logoComponent | Out-File -FilePath $outputFile -Encoding UTF8
Write-Success "Generated: $outputFile"

# Generate integration instructions
$integrationGuide = @'
# Logo Integration Guide

## Files to Update:

### 1. Header Component (`/src/components/Header.tsx`)
Replace the shield/square logo with:
```tsx
import { HeaderLogo } from '@/components/Logo';
// Use: <HeaderLogo darkMode={isDarkMode} />
```

### 2. Footer Component (`/src/components/Footer.tsx`)
Replace existing logos with:
```tsx
import { FooterLogos } from '@/components/Logo';
// Use: <FooterLogos darkMode={true} />
```

### 3. Navigation (`/src/components/Navigation.tsx`)
Update logo imports and usage.

### 4. Add Logo Files:
Place logo files in `/public/logos/`:
- disaster-recovery-logo.png
- nrp-logo.png
- combined-logo.png

## Implementation Steps:
1. Copy generated component to `/src/components/Logo.tsx`
2. Add logo image files to `/public/logos/`
3. Update all components using old logo system
4. Test responsive sizing and dark mode
'@

$guideFile = "$OutputPath/integration_guide_$timestamp.md"
$integrationGuide | Out-File -FilePath $guideFile -Encoding UTF8
Write-Success "Generated: $guideFile"

# Display summary
Write-Info "`n========================================="
Write-Info "Generation Summary"
Write-Info "========================================="

Write-Success "Logo component generated"
Write-Success "Integration guide created"

if ($stats) {
    Write-Info "`nAPI Usage:"
    Write-Info "- Tokens: $($stats.processor.tokenUsage)"
    Write-Info "- Cost: `$$([math]::Round($stats.processor.estimatedCost, 4))"
}

Write-Info "`nGenerated Files:"
Write-Info "1. Component: $outputFile"
Write-Info "2. Guide: $guideFile"

Write-Warning "`nNOTE: Test mode - No Git operations performed"

Write-Info "`nNext Steps:"
Write-Info "1. Review the generated logo component"
Write-Info "2. Add actual logo files to /public/logos/"
Write-Info "3. Integrate into existing components"
Write-Info "4. Test before committing"

# Show preview of the component
Write-Info "`n========================================="
Write-Info "Component Preview (First 20 lines):"
Write-Info "========================================="
Get-Content $outputFile -TotalCount 20 | ForEach-Object { Write-Host $_ -ForegroundColor Gray }

Write-Success "`nPipeline Test Complete!"